<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ManifestVerifier.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">bagit</a> &gt; <a href="index.source.html" class="el_package">nl.knaw.dans.bagit.verify</a> &gt; <span class="el_source">ManifestVerifier.java</span></div><h1>ManifestVerifier.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2023 DANS - Data Archiving and Networked Services (info@dans.knaw.nl)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package nl.knaw.dans.bagit.verify;

import java.io.IOException;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.HashSet;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.concurrent.ConcurrentSkipListSet;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import nl.knaw.dans.bagit.domain.Bag;
import nl.knaw.dans.bagit.exceptions.FileNotInPayloadDirectoryException;
import nl.knaw.dans.bagit.exceptions.InvalidBagitFileFormatException;
import nl.knaw.dans.bagit.exceptions.MaliciousPathException;
import nl.knaw.dans.bagit.exceptions.UnsupportedAlgorithmException;
import nl.knaw.dans.bagit.reader.ManifestReader;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.helpers.MessageFormatter;

import nl.knaw.dans.bagit.domain.Manifest;
import nl.knaw.dans.bagit.domain.Version;
import nl.knaw.dans.bagit.hash.BagitAlgorithmNameToSupportedAlgorithmMapping;
import nl.knaw.dans.bagit.hash.StandardBagitAlgorithmNameToSupportedAlgorithmMapping;
import nl.knaw.dans.bagit.util.PathUtils;

/**
 * Responsible for all things related to the manifest during verification.
 */
public class ManifestVerifier implements AutoCloseable{
<span class="fc" id="L50">  private static final Logger logger = LoggerFactory.getLogger(ManifestVerifier.class);</span>
<span class="fc" id="L51">  private static final ResourceBundle messages = ResourceBundle.getBundle(&quot;MessageBundle&quot;);</span>

  private transient final BagitAlgorithmNameToSupportedAlgorithmMapping nameMapping;
  private transient final ExecutorService executor;
  
  /**
   * Create a PayloadVerifier using a cached thread pool and the 
   * {@link StandardBagitAlgorithmNameToSupportedAlgorithmMapping} mapping
   */
  public ManifestVerifier(){
<span class="fc" id="L61">    this(new StandardBagitAlgorithmNameToSupportedAlgorithmMapping(), Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()));</span>
<span class="fc" id="L62">  }</span>

  /**
   * Create a PayloadVerifier using a cached thread pool and a custom mapping
   * 
   * @param nameMapping the mapping between BagIt algorithm name and the java supported algorithm
   */
  public ManifestVerifier(final BagitAlgorithmNameToSupportedAlgorithmMapping nameMapping) {
<span class="fc" id="L70">    this(nameMapping, Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()));</span>
<span class="fc" id="L71">  }</span>
  
  /**
   * Create a PayloadVerifier using a custom thread pool and the 
   * {@link StandardBagitAlgorithmNameToSupportedAlgorithmMapping} mapping
   * 
   * @param executor the thread pool to use when doing work
   */
  public ManifestVerifier(final ExecutorService executor) {
<span class="fc" id="L80">    this(new StandardBagitAlgorithmNameToSupportedAlgorithmMapping(), executor);</span>
<span class="fc" id="L81">  }</span>
  
  /**
   * Create a PayloadVerifier using a custom thread pool and a custom mapping
   * 
   * @param nameMapping the mapping between BagIt algorithm name and the java supported algorithm
   * @param executor the thread pool to use when doing work
   */
<span class="fc" id="L89">  public ManifestVerifier(final BagitAlgorithmNameToSupportedAlgorithmMapping nameMapping, final ExecutorService executor) {</span>
<span class="fc" id="L90">    this.nameMapping = nameMapping;</span>
<span class="fc" id="L91">    this.executor = executor;</span>
<span class="fc" id="L92">  }</span>
  
  @Override
  public void close() throws SecurityException{
    //shutdown the thread pool so the resource isn't leaked
<span class="fc" id="L97">    executor.shutdown();</span>
<span class="fc" id="L98">  }</span>

  /**
   * Verify that all the files in the payload directory are listed in the payload manifest and 
   * all files listed in all manifests exist.
   * 
   * @param bag the bag to check to check
   * @param ignoreHiddenFiles to ignore hidden files unless they are specifically listed in a manifest
   * 
   * @throws IOException if there is a problem reading a file
   * @throws MaliciousPathException the path in the manifest was specifically crafted to cause harm
   * @throws UnsupportedAlgorithmException if the algorithm used for the manifest is unsupported
   * @throws InvalidBagitFileFormatException if any of the manifests don't conform to the bagit specification
   * @throws FileNotInPayloadDirectoryException if a file is listed in a manifest but doesn't exist in the payload directory
   * @throws InterruptedException if a thread is interrupted while doing work
   */
  public void verifyManifests(final Bag bag, final boolean ignoreHiddenFiles)
      throws IOException, MaliciousPathException, UnsupportedAlgorithmException, 
      InvalidBagitFileFormatException, FileNotInPayloadDirectoryException, InterruptedException {
    
<span class="fc" id="L118">    final Set&lt;Path&gt; allFilesListedInManifests = getAllFilesListedInManifests(bag);</span>
<span class="fc" id="L119">    checkAllFilesListedInManifestExist(allFilesListedInManifests);</span>

<span class="fc bfc" id="L121" title="All 2 branches covered.">    if (bag.getVersion().isOlder(new Version(1, 0))) {</span>
<span class="fc" id="L122">      checkAllFilesInPayloadDirAreListedInAtLeastOneAManifest(allFilesListedInManifests, PathUtils.getDataDir(bag), ignoreHiddenFiles);</span>
    } else {
<span class="fc" id="L124">      CheckAllFilesInPayloadDirAreListedInAllManifests(bag.getPayLoadManifests(), PathUtils.getDataDir(bag), ignoreHiddenFiles);</span>
    }
<span class="fc" id="L126">  }</span>

  /*
   * get all the files listed in all the manifests
   */
  private Set&lt;Path&gt; getAllFilesListedInManifests(final Bag bag)
      throws IOException, MaliciousPathException, UnsupportedAlgorithmException, InvalidBagitFileFormatException {
<span class="fc" id="L133">    logger.debug(messages.getString(&quot;all_files_in_manifests&quot;));</span>
<span class="fc" id="L134">    final Set&lt;Path&gt; filesListedInManifests = new HashSet&lt;&gt;();</span>

<span class="fc" id="L136">    try(DirectoryStream&lt;Path&gt; directoryStream = </span>
<span class="fc" id="L137">        Files.newDirectoryStream(PathUtils.getBagitDir(bag.getVersion(), bag.getRootDir()))){</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">      for (final Path path : directoryStream) {</span>
<span class="fc" id="L139">        final String filename = PathUtils.getFilename(path);</span>
<span class="fc bfc" id="L140" title="All 4 branches covered.">        if (filename.startsWith(&quot;tagmanifest-&quot;) || filename.startsWith(&quot;manifest-&quot;)) {</span>
<span class="fc" id="L141">          logger.debug(messages.getString(&quot;get_listing_in_manifest&quot;), path);</span>
<span class="fc" id="L142">          final Manifest manifest = ManifestReader.readManifest(nameMapping, path, bag.getRootDir(),</span>
<span class="fc" id="L143">              bag.getFileEncoding());</span>
<span class="fc" id="L144">          filesListedInManifests.addAll(manifest.getFileToChecksumMap().keySet());</span>
        }
<span class="fc" id="L146">      }</span>
    }

<span class="fc" id="L149">    return filesListedInManifests;</span>
  }

  /*
   * Make sure all the listed files actually exist
   */
  @SuppressWarnings(&quot;PMD.AvoidInstantiatingObjectsInLoops&quot;)
  private void checkAllFilesListedInManifestExist(final Set&lt;Path&gt; files) throws FileNotInPayloadDirectoryException, InterruptedException {
<span class="fc" id="L157">    final CountDownLatch latch = new CountDownLatch(files.size());</span>
<span class="fc" id="L158">    final Set&lt;Path&gt; missingFiles = new ConcurrentSkipListSet&lt;&gt;();</span>

<span class="fc" id="L160">    logger.info(messages.getString(&quot;check_all_files_in_manifests_exist&quot;));</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">    for (final Path file : files) {</span>
<span class="fc" id="L162">      executor.execute(new CheckIfFileExistsTask(file, missingFiles, latch));</span>
<span class="fc" id="L163">    }</span>

<span class="fc" id="L165">    latch.await();</span>

<span class="fc bfc" id="L167" title="All 2 branches covered.">    if (!missingFiles.isEmpty()) {</span>
<span class="fc" id="L168">      final String formattedMessage = messages.getString(&quot;missing_payload_files_error&quot;);</span>
<span class="fc" id="L169">      throw new FileNotInPayloadDirectoryException(MessageFormatter.format(formattedMessage, missingFiles).getMessage());</span>
    }
<span class="fc" id="L171">  }</span>

  /*
   * Make sure all files in the directory are in at least 1 manifest
   */
  private static void checkAllFilesInPayloadDirAreListedInAtLeastOneAManifest(final Set&lt;Path&gt; filesListedInManifests,
      final Path payloadDir, final boolean ignoreHiddenFiles) throws IOException {
<span class="fc" id="L178">    logger.debug(messages.getString(&quot;checking_file_in_at_least_one_manifest&quot;), payloadDir);</span>
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">    if (Files.exists(payloadDir)) {</span>
<span class="fc" id="L180">      Files.walkFileTree(payloadDir,</span>
          new PayloadFileExistsInAtLeastOneManifestVistor(filesListedInManifests, ignoreHiddenFiles));
    }
<span class="fc" id="L183">  }</span>

  /*
   * as per the bagit-spec 1.0+ all files have to be listed in all manifests
   */
  private static void CheckAllFilesInPayloadDirAreListedInAllManifests(final Set&lt;Manifest&gt; payLoadManifests,
      final Path payloadDir, final boolean ignoreHiddenFiles) throws IOException {
<span class="fc" id="L190">    logger.debug(messages.getString(&quot;checking_file_in_all_manifests&quot;), payloadDir);</span>
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">    if (Files.exists(payloadDir)) {</span>
<span class="fc" id="L192">      Files.walkFileTree(payloadDir, new PayloadFileExistsInAllManifestsVistor(payLoadManifests, ignoreHiddenFiles));</span>
    }
<span class="fc" id="L194">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>