<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BagWriter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">bagit</a> &gt; <a href="index.source.html" class="el_package">nl.knaw.dans.bagit.writer</a> &gt; <span class="el_source">BagWriter.java</span></div><h1>BagWriter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2023 DANS - Data Archiving and Networked Services (info@dans.knaw.nl)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package nl.knaw.dans.bagit.writer;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.HashSet;
import java.util.Map.Entry;
import java.util.ResourceBundle;
import java.util.Set;

import nl.knaw.dans.bagit.domain.Bag;
import nl.knaw.dans.bagit.domain.Manifest;
import nl.knaw.dans.bagit.hash.Hasher;
import nl.knaw.dans.bagit.util.PathUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * responsible for writing out a {@link Bag}
 */
public final class BagWriter {
<span class="fc" id="L39">  private static final Logger logger = LoggerFactory.getLogger(BagWriter.class);</span>
<span class="fc" id="L40">  private static final ResourceBundle messages = ResourceBundle.getBundle(&quot;MessageBundle&quot;);</span>

  private BagWriter(){
    //intentionally left empty
  }
  
  /**
   * Write the bag out to the specified directory. 
   * If an error occurs some of the files may have been written out to the filesystem.
   * tag manifest(s) are updated prior to writing to ensure bag is valid after completion, 
   * it is therefore recommended if you are going to further interact with the bag to read it from specified outputDir path
   * 
   * @param bag the {@link Bag} object to write out
   * @param outputDir the output directory that will become the root of the bag
   * 
   * @throws IOException if there is a problem writing a file
   * @throws NoSuchAlgorithmException when trying to generate a {@link MessageDigest} which is used during update.
   */
  public static void write(final Bag bag, final Path outputDir) throws IOException, NoSuchAlgorithmException{
<span class="fc" id="L59">    logger.debug(messages.getString(&quot;writing_payload_files&quot;));</span>
<span class="fc" id="L60">    final Path bagitDir = PayloadWriter.writeVersionDependentPayloadFiles(bag, outputDir);</span>
    
<span class="fc" id="L62">    logger.debug(messages.getString(&quot;upsert_payload_oxum&quot;));</span>
<span class="fc" id="L63">    final String payloadOxum = PathUtils.generatePayloadOxum(PathUtils.getDataDir(bag.getVersion(), outputDir));</span>
<span class="fc" id="L64">    bag.getMetadata().upsertPayloadOxum(payloadOxum);</span>
    
<span class="fc" id="L66">    logger.debug(messages.getString(&quot;writing_bagit_file&quot;));</span>
<span class="fc" id="L67">    BagitFileWriter.writeBagitFile(bag.getVersion(), bag.getFileEncoding(), bagitDir);</span>
    
<span class="fc" id="L69">    logger.debug(messages.getString(&quot;writing_payload_manifests&quot;));</span>
<span class="fc" id="L70">    ManifestWriter.writePayloadManifests(bag.getPayLoadManifests(), bagitDir, bag.getRootDir(), bag.getFileEncoding());</span>

<span class="pc bpc" id="L72" title="1 of 2 branches missed.">    if(!bag.getMetadata().isEmpty()){</span>
<span class="fc" id="L73">      logger.debug(messages.getString(&quot;writing_bag_metadata&quot;));</span>
<span class="fc" id="L74">      MetadataWriter.writeBagMetadata(bag.getMetadata(), bag.getVersion(), bagitDir, bag.getFileEncoding());</span>
    }
<span class="fc bfc" id="L76" title="All 2 branches covered.">    if(bag.getItemsToFetch().size() &gt; 0){</span>
<span class="fc" id="L77">      logger.debug(messages.getString(&quot;writing_fetch_file&quot;));</span>
<span class="fc" id="L78">      FetchWriter.writeFetchFile(bag.getItemsToFetch(), bagitDir, bag.getRootDir(), bag.getFileEncoding());</span>
    }
<span class="fc bfc" id="L80" title="All 2 branches covered.">    if(bag.getTagManifests().size() &gt; 0){</span>
<span class="fc" id="L81">      logger.debug(messages.getString(&quot;writing_tag_manifests&quot;));</span>
<span class="fc" id="L82">      writeTagManifestFiles(bag.getTagManifests(), bagitDir, bag.getRootDir());</span>
<span class="fc" id="L83">      final Set&lt;Manifest&gt; updatedTagManifests = updateTagManifests(bag, outputDir);</span>
<span class="fc" id="L84">      bag.setTagManifests(updatedTagManifests);</span>
<span class="fc" id="L85">      ManifestWriter.writeTagManifests(updatedTagManifests, bagitDir, outputDir, bag.getFileEncoding());</span>
    }
<span class="fc" id="L87">  }</span>
  
  /*
   * Update the tag manifest cause the checksum of the other tag files will have changed since we just wrote them out to disk
   */
  @SuppressWarnings(&quot;PMD.AvoidInstantiatingObjectsInLoops&quot;)
  private static Set&lt;Manifest&gt; updateTagManifests(final Bag bag, final Path newBagRootDir) throws NoSuchAlgorithmException, IOException{
<span class="fc" id="L94">    final Set&lt;Manifest&gt; newManifests = new HashSet&lt;&gt;();</span>
    
<span class="fc bfc" id="L96" title="All 2 branches covered.">    for(final Manifest tagManifest : bag.getTagManifests()){</span>
<span class="fc" id="L97">      final Manifest newManifest = new Manifest(tagManifest.getAlgorithm());</span>
      
<span class="fc bfc" id="L99" title="All 2 branches covered.">      for(final Path originalPath : tagManifest.getFileToChecksumMap().keySet()){</span>
<span class="fc" id="L100">        final Path relativePath = bag.getRootDir().relativize(originalPath);</span>
<span class="fc" id="L101">        final Path pathToUpdate = newBagRootDir.resolve(relativePath);</span>
<span class="fc" id="L102">        final MessageDigest messageDigest = MessageDigest.getInstance(tagManifest.getAlgorithm().getMessageDigestName());</span>
<span class="fc" id="L103">        final String newChecksum = Hasher.hash(pathToUpdate, messageDigest);</span>
<span class="fc" id="L104">        newManifest.getFileToChecksumMap().put(pathToUpdate, newChecksum);</span>
<span class="fc" id="L105">      }</span>
      
<span class="fc" id="L107">      newManifests.add(newManifest);</span>
<span class="fc" id="L108">    }</span>
    
<span class="fc" id="L110">    return newManifests;</span>
  }
  
  /*
   * Write the tag manifest files
   */
  private static void writeTagManifestFiles(final Set&lt;Manifest&gt; manifests, final Path outputDir, final Path bagRootDir) throws IOException{
<span class="fc bfc" id="L117" title="All 2 branches covered.">    for(final Manifest manifest : manifests){</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">      for(final Entry&lt;Path, String&gt; entry : manifest.getFileToChecksumMap().entrySet()){</span>
<span class="fc" id="L119">        final Path relativeLocation = bagRootDir.relativize(entry.getKey());</span>
<span class="fc" id="L120">        final Path writeTo = outputDir.resolve(relativeLocation);</span>
<span class="fc" id="L121">        final Path writeToParent = writeTo.getParent();</span>
<span class="pc bpc" id="L122" title="1 of 4 branches missed.">        if(!Files.exists(writeTo) &amp;&amp; writeToParent != null){</span>
<span class="fc" id="L123">          Files.createDirectories(writeToParent);</span>
<span class="fc" id="L124">          Files.copy(entry.getKey(), writeTo);</span>
        }
<span class="fc" id="L126">      }</span>
<span class="fc" id="L127">    }</span>
<span class="fc" id="L128">  }</span>
  
  
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>