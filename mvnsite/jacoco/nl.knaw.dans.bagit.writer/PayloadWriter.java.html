<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PayloadWriter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">bagit</a> &gt; <a href="index.source.html" class="el_package">nl.knaw.dans.bagit.writer</a> &gt; <span class="el_source">PayloadWriter.java</span></div><h1>PayloadWriter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2023 DANS - Data Archiving and Networked Services (info@dans.knaw.nl)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package nl.knaw.dans.bagit.writer;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.util.HashSet;
import java.util.List;
import java.util.ResourceBundle;
import java.util.Set;

import nl.knaw.dans.bagit.domain.Bag;
import nl.knaw.dans.bagit.domain.FetchItem;
import nl.knaw.dans.bagit.domain.Manifest;
import nl.knaw.dans.bagit.domain.Version;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Responsible for writing out the bag payload to the filesystem
 */
public final class PayloadWriter {
<span class="fc" id="L38">  private static final Logger logger = LoggerFactory.getLogger(PayloadWriter.class);</span>
<span class="fc" id="L39">  private static final Version VERSION_2_0 = new Version(2, 0);</span>
<span class="fc" id="L40">  private static final ResourceBundle messages = ResourceBundle.getBundle(&quot;MessageBundle&quot;);</span>
  
  private PayloadWriter(){
    //intentionally left empty
  }
  
  /*
   * Write the payload files in the data directory or under the root directory depending on the version
   */
  static Path writeVersionDependentPayloadFiles(final Bag bag, final Path outputDir) throws IOException{
<span class="fc" id="L50">    Path bagitDir = outputDir;</span>
    //@Incubating
<span class="fc bfc" id="L52" title="All 2 branches covered.">    if(bag.getVersion().isSameOrNewer(VERSION_2_0)){</span>
<span class="fc" id="L53">      bagitDir = outputDir.resolve(&quot;.bagit&quot;);</span>
<span class="fc" id="L54">      Files.createDirectories(bagitDir);</span>
<span class="fc" id="L55">      writePayloadFiles(bag.getPayLoadManifests(), bag.getItemsToFetch(), outputDir, bag.getRootDir());</span>
    }
    else{
<span class="fc" id="L58">      final Path dataDir = outputDir.resolve(&quot;data&quot;);</span>
<span class="fc" id="L59">      Files.createDirectories(dataDir);</span>
<span class="fc" id="L60">      writePayloadFiles(bag.getPayLoadManifests(), bag.getItemsToFetch(), dataDir, bag.getRootDir().resolve(&quot;data&quot;));</span>
    }
    
<span class="fc" id="L63">    return bagitDir;</span>
  }
  
  /**
  * Write the payload &lt;b&gt;file(s)&lt;/b&gt; to the output directory
  * 
  * @param payloadManifests the set of objects representing the payload manifests
  * @param fetchItems the list of items to exclude from writing in the output directory because they will be fetched
  * @param outputDir the data directory of the bag
  * @param bagDataDir the data directory of the bag
  * 
  * @throws IOException if there was a problem writing a file
  */
 public static void writePayloadFiles(final Set&lt;Manifest&gt; payloadManifests, final List&lt;FetchItem&gt; fetchItems, final Path outputDir, final Path bagDataDir) throws IOException{
<span class="fc" id="L77">   logger.info(messages.getString(&quot;writing_payload_files&quot;));</span>
<span class="fc" id="L78">   final Set&lt;Path&gt; fetchPaths = getFetchPaths(fetchItems, bagDataDir);</span>
   
<span class="fc bfc" id="L80" title="All 2 branches covered.">   for(final Manifest payloadManifest : payloadManifests){</span>
<span class="fc bfc" id="L81" title="All 2 branches covered.">     for(final Path payloadFile : payloadManifest.getFileToChecksumMap().keySet()){</span>
<span class="fc" id="L82">       final Path relativePayloadPath = bagDataDir.relativize(payloadFile);</span>
       
<span class="fc bfc" id="L84" title="All 2 branches covered.">       if(fetchPaths.contains(relativePayloadPath.normalize())) {</span>
<span class="fc" id="L85">         logger.info(messages.getString(&quot;skip_fetch_item_when_writing_payload&quot;), payloadFile);</span>
       }
       else {
<span class="fc" id="L88">         final Path writeToPath = outputDir.resolve(relativePayloadPath);</span>
<span class="fc" id="L89">         logger.debug(messages.getString(&quot;writing_payload_file_to_path&quot;), payloadFile, writeToPath);</span>
<span class="fc" id="L90">         final Path parent = writeToPath.getParent();</span>
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">         if(parent != null){</span>
<span class="fc" id="L92">           Files.createDirectories(parent);</span>
         }
<span class="fc" id="L94">         Files.copy(payloadFile, writeToPath, StandardCopyOption.COPY_ATTRIBUTES, StandardCopyOption.REPLACE_EXISTING);</span>
       }
<span class="fc" id="L96">     }</span>
<span class="fc" id="L97">   }</span>
<span class="fc" id="L98"> }</span>
 
  private static Set&lt;Path&gt; getFetchPaths(final List&lt;FetchItem&gt; fetchItems, final Path bagDataDir) {
<span class="fc" id="L101">    final Set&lt;Path&gt; fetchPaths = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">    for (final FetchItem fetchItem : fetchItems) {</span>
<span class="fc" id="L103">      final Path parent = bagDataDir.getParent();</span>
<span class="pc bpc" id="L104" title="1 of 2 branches missed.">      if(parent != null){</span>
<span class="fc" id="L105">        fetchPaths.add(bagDataDir.relativize(parent.resolve(fetchItem.getPath())));</span>
      }
<span class="fc" id="L107">    }</span>
<span class="fc" id="L108">    return fetchPaths;</span>
 }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>