<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BagCreator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">bagit</a> &gt; <a href="index.source.html" class="el_package">nl.knaw.dans.bagit.creator</a> &gt; <span class="el_source">BagCreator.java</span></div><h1>BagCreator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2023 DANS - Data Archiving and Networked Services (info@dans.knaw.nl)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package nl.knaw.dans.bagit.creator;

import java.io.IOException;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.text.SimpleDateFormat;
import java.util.Collection;
import java.util.Date;
import java.util.Locale;
import java.util.Map;
import java.util.ResourceBundle;

import nl.knaw.dans.bagit.annotation.Incubating;
import nl.knaw.dans.bagit.domain.Bag;
import nl.knaw.dans.bagit.domain.Manifest;
import nl.knaw.dans.bagit.hash.Hasher;
import nl.knaw.dans.bagit.hash.SupportedAlgorithm;
import nl.knaw.dans.bagit.util.PathUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import nl.knaw.dans.bagit.domain.Metadata;
import nl.knaw.dans.bagit.domain.Version;
import nl.knaw.dans.bagit.writer.BagitFileWriter;
import nl.knaw.dans.bagit.writer.ManifestWriter;
import nl.knaw.dans.bagit.writer.MetadataWriter;

/**
 * Responsible for creating a bag in place.
 */
@SuppressWarnings(&quot;PMD.TooManyMethods&quot;)
public final class BagCreator {
<span class="fc" id="L51">  private static final Logger logger = LoggerFactory.getLogger(BagCreator.class);</span>
<span class="fc" id="L52">  private static final ResourceBundle messages = ResourceBundle.getBundle(&quot;MessageBundle&quot;);</span>
  private static final String DATE_FORMAT = &quot;yyyy-MM-dd&quot;;
<span class="fc" id="L54">  private static final Version DOT_BAGIT_VERSION = new Version(2, 0);</span>
<span class="fc" id="L55">  private static final Version LATEST_NON_DOT_BAGIT_VERSION = Version.LATEST_BAGIT_VERSION();</span>
  
  private BagCreator(){}
  
  /**
   * Creates a bag in place for version 0.97.
   * This method moves and creates files, thus if an error is thrown during operation it may leave the filesystem 
   * in an unknown state of transition. Thus this is &lt;b&gt;not thread safe&lt;/b&gt;
   * 
   * @param root the directory that will become the base of the bag and where to start searching for content
   * @param algorithms an collection of {@link SupportedAlgorithm} implementations
   * @param includeHidden to include hidden files when generating the bagit files, like the manifests
   * 
   * @throws NoSuchAlgorithmException if {@link MessageDigest} can't find the algorithm
   * @throws IOException if there is a problem writing or moving file(s)
   * 
   * @return a {@link Bag} object representing the newly created bagit bag
   */
  public static Bag bagInPlace(final Path root, final Collection&lt;SupportedAlgorithm&gt; algorithms, final boolean includeHidden) throws NoSuchAlgorithmException, IOException{
<span class="fc" id="L74">    return bagInPlace(LATEST_NON_DOT_BAGIT_VERSION, root, algorithms, includeHidden, new Metadata());</span>
  }
  
  /**
   * Creates a bag in place for version 0.97.
   * This method moves and creates files, thus if an error is thrown during operation it may leave the filesystem 
   * in an unknown state of transition. Thus this is &lt;b&gt;not thread safe&lt;/b&gt;
   * 
   * @param root the directory that will become the base of the bag and where to start searching for content
   * @param algorithms an collection of {@link SupportedAlgorithm} implementations
   * @param includeHidden to include hidden files when generating the bagit files, like the manifests
   * @param metadata the metadata to include when creating the bag. Payload-Oxum and Bagging-Date will be overwritten 
   * 
   * @throws NoSuchAlgorithmException if {@link MessageDigest} can't find the algorithm
   * @throws IOException if there is a problem writing or moving file(s)
   * 
   * @return a {@link Bag} object representing the newly created bagit bag
   */
  public static Bag bagInPlace(final Path root, final Collection&lt;SupportedAlgorithm&gt; algorithms, final boolean includeHidden, final Metadata metadata) throws NoSuchAlgorithmException, IOException{
<span class="nc" id="L93">    return bagInPlace(LATEST_NON_DOT_BAGIT_VERSION, root, algorithms, includeHidden, metadata);</span>
  }
  
  /**
   * Creates a basic(only required elements) .bagit bag in place.
   * This creates files and directories, thus if an error is thrown during operation it may leave the filesystem 
   * in an unknown state of transition. Thus this is &lt;b&gt;not thread safe&lt;/b&gt;
   * 
   * @param root the directory that will become the base of the bag and where to start searching for content
   * @param algorithms an collection of {@link SupportedAlgorithm} implementations
   * @param includeHidden to include hidden files when generating the bagit files, like the manifests
   * 
   * @throws NoSuchAlgorithmException if {@link MessageDigest} can't find the algorithm
   * @throws IOException if there is a problem writing files or .bagit directory
   * 
   * @return a {@link Bag} object representing the newly created bagit bag
   */
  @Incubating
  public static Bag createDotBagit(final Path root, final Collection&lt;SupportedAlgorithm&gt; algorithms, final boolean includeHidden) throws NoSuchAlgorithmException, IOException{
<span class="fc" id="L112">    return bagInPlace(DOT_BAGIT_VERSION, root, algorithms, includeHidden, new Metadata());</span>
  }
  
  /**
   * Creates a basic(only required elements) .bagit bag in place.
   * This creates files and directories, thus if an error is thrown during operation it may leave the filesystem 
   * in an unknown state of transition. Thus this is &lt;b&gt;not thread safe&lt;/b&gt;
   * 
   * @param root the directory that will become the base of the bag and where to start searching for content
   * @param algorithms an collection of {@link SupportedAlgorithm} implementations
   * @param includeHidden to include hidden files when generating the bagit files, like the manifests
   * @param metadata the metadata to include when creating the bag. Payload-Oxum and Bagging-Date will be overwritten
   * 
   * @throws NoSuchAlgorithmException if {@link MessageDigest} can't find the algorithm
   * @throws IOException if there is a problem writing files or .bagit directory
   * 
   * @return a {@link Bag} object representing the newly created bagit bag
   */
  @Incubating
  public static Bag createDotBagit(final Path root, final Collection&lt;SupportedAlgorithm&gt; algorithms, final boolean includeHidden, final Metadata metadata) throws NoSuchAlgorithmException, IOException{
<span class="nc" id="L132">    return bagInPlace(DOT_BAGIT_VERSION, root, algorithms, includeHidden, metadata);</span>
  }
  
  private static Bag bagInPlace(final Version version, final Path root, final Collection&lt;SupportedAlgorithm&gt; algorithms, final boolean includeHidden, final Metadata metadata) throws NoSuchAlgorithmException, IOException{
<span class="fc" id="L136">    final Bag bag = new Bag(version);</span>
<span class="fc" id="L137">    logger.info(messages.getString(&quot;creating_bag&quot;), bag.getVersion(), root);</span>
<span class="fc" id="L138">    bag.setRootDir(root);</span>
    
<span class="fc" id="L140">    moveDataFilesIfNeeded(bag, includeHidden);</span>
    
<span class="fc" id="L142">    createBagitFile(bag);</span>

<span class="fc" id="L144">    createPayloadManifests(bag, algorithms, includeHidden);</span>
    
<span class="fc" id="L146">    createMetadataFile(bag, metadata);</span>
    
<span class="fc" id="L148">    createTagManifests(bag, algorithms, includeHidden);</span>
    
<span class="fc" id="L150">    return bag;</span>
  }
  
  private static void moveDataFilesIfNeeded(final Bag bag, final boolean includeHidden) throws IOException {
<span class="fc bfc" id="L154" title="All 2 branches covered.">    if(bag.getVersion().isOlder(DOT_BAGIT_VERSION)) {</span>
<span class="fc" id="L155">      final Path tempDir = bag.getRootDir().resolve(System.currentTimeMillis() + &quot;.temp&quot;);</span>
<span class="fc" id="L156">      Files.createDirectory(tempDir);</span>
<span class="fc" id="L157">      moveDataFiles(bag.getRootDir(), tempDir, includeHidden);</span>
<span class="fc" id="L158">      Files.move(tempDir, PathUtils.getDataDir(bag));</span>
<span class="fc" id="L159">    }</span>
    else {
<span class="fc" id="L161">      final Path dotbagitDir = bag.getRootDir().resolve(&quot;.bagit&quot;);</span>
<span class="fc" id="L162">      Files.createDirectories(dotbagitDir);</span>
    }
<span class="fc" id="L164">  }</span>
  
  private static void createBagitFile(final Bag bag) throws IOException{
<span class="fc" id="L167">    BagitFileWriter.writeBagitFile(bag.getVersion(), bag.getFileEncoding(), PathUtils.getBagitDir(bag));</span>
<span class="fc" id="L168">  }</span>
  
  private static void moveDataFiles(final Path rootDir, final Path dataDir, final boolean includeHidden) throws IOException{
<span class="fc" id="L171">    try(final DirectoryStream&lt;Path&gt; directoryStream = Files.newDirectoryStream(rootDir)){</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">      for(final Path path : directoryStream){</span>
<span class="fc bfc" id="L173" title="All 6 branches covered.">        if(!path.equals(dataDir) &amp;&amp; (!PathUtils.isHidden(path) || includeHidden)){</span>
<span class="fc" id="L174">          Files.move(path, dataDir.resolve(path.getFileName()));</span>
        }
<span class="fc" id="L176">      }</span>
    }
<span class="fc" id="L178">  }</span>
  
  private static Map&lt;Manifest, MessageDigest&gt; calculatePayloadManifests(final Bag bag, final Collection&lt;SupportedAlgorithm&gt; algorithms, final boolean includeHidden) throws NoSuchAlgorithmException, IOException{
<span class="fc" id="L181">    final Path dataDir = PathUtils.getDataDir(bag);</span>
<span class="fc" id="L182">    logger.info(messages.getString(&quot;creating_payload_manifests&quot;));</span>
<span class="fc" id="L183">    final Map&lt;Manifest, MessageDigest&gt; payloadFilesMap = Hasher.createManifestToMessageDigestMap(algorithms);</span>
<span class="fc" id="L184">    final CreatePayloadManifestsVistor payloadVisitor = new CreatePayloadManifestsVistor(payloadFilesMap, includeHidden);</span>
<span class="fc" id="L185">    Files.walkFileTree(dataDir, payloadVisitor);</span>
    
<span class="fc" id="L187">    return payloadFilesMap;</span>
  }
  
  private static void createPayloadManifests(final Bag bag, final Collection&lt;SupportedAlgorithm&gt; algorithms, final boolean includeHidden) throws NoSuchAlgorithmException, IOException{
<span class="fc" id="L191">    final Map&lt;Manifest, MessageDigest&gt; payloadFilesMap = calculatePayloadManifests(bag, algorithms, includeHidden);</span>
<span class="fc" id="L192">    bag.getPayLoadManifests().addAll(payloadFilesMap.keySet());</span>
<span class="fc" id="L193">    ManifestWriter.writePayloadManifests(bag.getPayLoadManifests(), PathUtils.getBagitDir(bag), bag.getRootDir(), bag.getFileEncoding());</span>
<span class="fc" id="L194">  }</span>
  
  private static void createMetadataFile(final Bag bag, final Metadata metadata) throws IOException{
<span class="fc" id="L197">    bag.setMetadata(metadata);</span>
    
<span class="fc" id="L199">    logger.debug(messages.getString(&quot;calculating_payload_oxum&quot;), PathUtils.getDataDir(bag));</span>
<span class="fc" id="L200">    final String payloadOxum = PathUtils.generatePayloadOxum(PathUtils.getDataDir(bag));</span>
<span class="fc" id="L201">    bag.getMetadata().upsertPayloadOxum(payloadOxum);</span>
    
<span class="fc" id="L203">    bag.getMetadata().remove(&quot;Bagging-Date&quot;); //remove the old bagging date if it exists so that there is only one</span>
<span class="fc" id="L204">    bag.getMetadata().add(&quot;Bagging-Date&quot;, new SimpleDateFormat(DATE_FORMAT, Locale.ENGLISH).format(new Date()));</span>
    
<span class="fc" id="L206">    logger.info(messages.getString(&quot;creating_metadata_file&quot;));</span>
<span class="fc" id="L207">    MetadataWriter.writeBagMetadata(bag.getMetadata(), bag.getVersion(), PathUtils.getBagitDir(bag), bag.getFileEncoding());</span>
<span class="fc" id="L208">  }</span>
  
  private static Map&lt;Manifest, MessageDigest&gt; calculateTagManifests(final Bag bag, final Collection&lt;SupportedAlgorithm&gt; algorithms, final boolean includeHidden) throws NoSuchAlgorithmException, IOException{
<span class="fc" id="L211">    logger.info(messages.getString(&quot;creating_tag_manifests&quot;));</span>
<span class="fc" id="L212">    final Map&lt;Manifest, MessageDigest&gt; tagFilesMap = Hasher.createManifestToMessageDigestMap(algorithms);</span>
<span class="fc" id="L213">    final CreateTagManifestsVistor tagVistor = new CreateTagManifestsVistor(tagFilesMap, includeHidden);</span>
<span class="fc" id="L214">    Files.walkFileTree(PathUtils.getBagitDir(bag), tagVistor);</span>
    
<span class="fc" id="L216">    return tagFilesMap;</span>
  }
  
  private static void createTagManifests(final Bag bag, final Collection&lt;SupportedAlgorithm&gt; algorithms, final boolean includeHidden) throws NoSuchAlgorithmException, IOException{
<span class="fc" id="L220">    final Map&lt;Manifest, MessageDigest&gt; tagFilesMap = calculateTagManifests(bag, algorithms, includeHidden);</span>
    
<span class="fc" id="L222">    bag.getTagManifests().addAll(tagFilesMap.keySet());</span>
<span class="fc" id="L223">    ManifestWriter.writeTagManifests(bag.getTagManifests(), PathUtils.getBagitDir(bag), bag.getRootDir(), bag.getFileEncoding());</span>
<span class="fc" id="L224">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>